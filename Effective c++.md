### Part1 一、让自己习惯C++

#### 条款01：视C++为一个语言联邦

​	C++并不是一个带有一组守则的一体语言：他是从四个次语言（C、Object-Oriented C++、Template、STL）组成的联邦政府，每个次语言都有自己的规约。记住这四个次语言就会发现C++容易了解得多。

​	C++高效编程守则视状况而变化，取决于你使用C++的哪一部分。



#### 条款02：尽量以const,enum,inline替换#define

```c
#define ASPECT_RATIO 1.653
```

以上句为例，是通过预处理器处理而不是编译器处理，有可能ASPET_RATIO没进入记号表内，于是如果出现了编译错误，那么编译器会提示1.653而不是ASPECT_RATIO，你会感到非常困惑。

解决的办法是用常量替换宏

```c
const double AspectRatio = 1.653;
```

这样编译器就可以看到ASPECT_RATIO，而且使用常量会使代码量变小，因为预处理器只会盲目的替换而出现多份的1.653。

string对象通常比char*更好一点。

对于class的专属常量，为了限制作用域在class内，并且防止产生多个实体，最好使用static

1. 如果你的编译器支持在类内对const static整数类型声明时获取初值，则使用。
2. 如果不支持，则在类内定义，在对应的实现文件中赋值。

如果需要在编译器就使用一个class常量值，则应最好改用枚举类型enum，且枚举不能用来取地址，不会为它分配额外的存储空间对于形似函数的宏，最好改用inline的模板函数。



#### 条款03：尽可能使用const

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：

条款01：





## Effevtive-Modern-Cpp

### part1 类型推导

#### 条款1：理解模板类型推导

- 模板类型推导的时候，有引用特性的参数的引用特性会被忽略。
- 在推导通用引用参数的时候，左值会被特殊处理
- 在推导按㨁传递的时候，const或volatile参数会被视为非const或非volatile
- 在模板类型推导的时候，参数如果是数组或者函数名称，他们会被退化成指针，除非是用在初始化引用类型。











