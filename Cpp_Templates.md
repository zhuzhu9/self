## 函数模板

定义函数模板：返回两个数之中的最大值：

```cpp
template<typename T>
T max(T a, T b)
{
    return b < a ? a : b;
}
```

模板参数是_typename T_ 。_typename_ 标识了一个类型参数。T是一个类型参数，在上面的例子中，类型T必须支持小于运算符，为了支持返回值，T还应该是可拷贝的。除了typename，也可使用class，为了避免一些歧义，最好使用typename。

##### 两阶段编译检查

在实例化模板的时候，如果模板参数类型不支持所有模板中用到的操作符，将会遇到编译期错误。

模板是被分为两步编译的：

1. 在模板定义阶段，模板的检查并不包含类型参数的检查，只包含：
   - 语法检查。
   - 使用了未定义的不依赖于模板参数的名称（类型名，函数名...）。
   - 未使用模板参数的static assertions。
2. 在模板实例化阶段，为确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分。

```cpp
template<typename T>
void foo(T t)
{
undeclared(); // 如果 undeclared()未定义,第一阶段就会报错,因为与模板参数无关
undeclared(t); //如果 undeclared(t)未定义,第二阶段会报错,因为与模板参数有关
static_assert(sizeof(int) > 10,"int too small");
// 与模板参数无关,总是报错
static_assert(sizeof(T) > 10, "T too small"); //与模板参数有关,只会在第二阶段报错
}
```

有些编译器并不会执行第一阶段中所有的检查。因此如果模板没有被至少实例化一次的话，可能一直都不会发现代码中的常规错误。

#### 模板参数推断

**类型推断中的类型转换**

在类型推断的时候自动的类型转换是受限制的：

- 如果调用的参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数T定义的两个参数，它们实参的类型必须完全一样。
- 如果调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的：const和volatile限制符会被忽略，引用被转换成被引用类型，raw array 和函数被转换为相应的指针类型。通过模板类型参数T定义的两个参数，它们实参类型在退化（decay）后必须一样。

类型推断不适用于默认调用参数，需要给模板类型参数声明一个默认参数。

```cpp
template<typename T = std::string>
void f(T = "");

f(); // OK
```





















