原子操作：是一类不可分割的操作，它的状态要么是完成，要么是未完成。



标准原子类型：

atomic types，这种类型的操作都是原子的，大多都有一个is_lock_free()成员函数，这个函数返回true时，允许用户决定是否可以直接对一个类型使用原子指令。

在std中，使用一些特化的原子类型，

| 原子类型        | 相关特化类                        |
| --------------- | --------------------------------- |
| atomic_bool     | std::atomic\<bool\>               |
| atomic_char     | std::atomic\<char\>               |
| atomic_schar    | std::atomic\<signed char\>        |
| atomic_uchar    | std::atomic\<unsigned char\>      |
| atomic_int      | std::atomic\<int\>                |
| atomic_uint     | std::atomic\<unsigned\>           |
| atomic_short    | std::atomic\<short\>              |
| atomic_ushort   | std::atomic\<unsigned short\>     |
| atomic_long     | std::atomic\<long\>               |
| atomic_ulong    | std::atomic\<unsigned long\>      |
| atomic_llong    | std::atomic\<long long\>          |
| atomic_ullong   | std::atomic\<unsigned long long\> |
| atomic_char16_t | std::atomic\<cahr16_t\>           |
| atomic_char32_t | std::atomic\<char32_t\>           |
| atomic_wchar_t  | std::atomic\<wchar_t\>            |

通常原子类型不能拷贝和赋值，没有拷贝构造函数和拷贝赋值函数。但是可以隐式转换成对应的内置类型，可以使用load()和store()成员函数等。支持：+=，-=，*=，/=。并可以支持整形和指针特化类型的++，--，支持原子类型的计算（fetch_add()等）。





std::atomic_flag

标准原子类型，表示一个bool，可以在设置和清除2个状态之间切换，

```c++
std::atomic_flag f = ATOMIC_FLAG_INIT; //这个标志总是初始化为"清除"
```

初始化完成后，只可以对此进行：销毁，清除和设置。clear()、test_and_set()。clear()是一个存储操作，test_and_set()是一个“读-改-写”的操作。

- test_and_set:将值设置为true，并返回原先的值。
- clear:清除，值设置为false.



memory order，给程序员提供了一种指定内存而不需要在乎硬件具体底层实现的手段，https://blog.csdn.net/wxj1992/article/details/103656486

memory_order_relaxed

宽松的内存序，使用这个内存序的原子操作仅仅保证自身的原子性，不会对任何其他变量的读写产生影响。不需要其他内存同步，使用这个内存序，比如计数器。

memory_order_consume

适用于原子读操作，对于采用此内存序的原子读操作，可以称之为consume operation

...



不能拷贝、赋值std::atomic_flag对象，适合作自旋锁，





std::atomic

std::atomic\<bool\>。

```c++
std::atomic<bool> b(true);
b = false;
```

“原子操作”正如其名称所示：该操作要么是执行完了，要么是没有执行，从任何一个线程中，都无法观察到中间状态。以原子读操作为例：如果有其他线程进行了原子写操作，那么原子读操作，要么获取到的是修改前的值，要么是修改后的，不会是修改了一半的值。

而非原子类型就不一样了。如果尝试修改非原子类型对象，其他线程可能看到的既不是修改前的值，也不是修改后的值。关于这一点，在C++ 并发编程中，我们就看到了非原子类型所引起的问题。

需要注意的是，**所有原子类型都不支持拷贝和赋值**。因为该操作涉及了两个原子对象：要先从另外一个原子对象上读取值，然后再写入另外一个原子对象。而对于两个不同的原子对象上单一操作不可能是原子的。

不同的原子类型包含了不同的原子操作，下表将原子类型分为四类，并列出了它们所支持的操作（为了简洁，列名上类名中的`atomic`用`#`代替）。

![img](https://pic1.zhimg.com/80/v2-1f17f9ece783020774eb4447666d5e98_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-83c9872baa4287750f059edf657f5a5d_720w.jpg)

**is_lock_free**

除了atomic_flag之外，其他的原子类型都支持is_lock_free。可以查询此类型的对象上原子操作是否免锁。

**load，store和exchange**

- load：原子地获取原子对象的值。
- store：原子地以非原子对象替换原子对象的值。
- exchange：原子地替换原子对象的的值并获得它先前的值。

参数和返回值都是非原子类型的值。

**比较和改变**

compare_exchange_weak和compare_exchange_strong。

都接受两个输入值：T& expected和T desired。这两个方法都会比较原子变量实际的值和所提供的预期值(expected)，如果两者相等，则更新原子变量值为其提供的期望值(desired)。否则，保持原子变量值不变。如果原子变量值发生了变化，则返回true，否则返回false。

**指针原子类型**

::std::atomic\<T*\>

- fetch_add或者+=：增加指定的值。
- fetch_sub或者-=：减少指定的值。
- ++和--：自加或自减。

**整形原子类型**

- fetch_add或者+=：增加指定的值。
- fetch_sub或者-=：减少指定的值。
- ++和--：自加或自减。
- “或”，“与”，“异或”

没有原子操作的乘法和除法。

原子类型操作中，命名函数（fetch_add）返回的是修改前的值。复合赋值运算符（+=）返回的是修改后的值。前缀和后缀和普通的一样（++，--）。



**用户定义类型**

::std::atomic\<UDT\>，这个类型必须有拷贝赋值运算符。不能有任何的虚函数和虚基类，必须使用编译器创建的拷贝赋值运算符。自定义类型中所有的基类和非静态数据成员也都需要支持拷贝赋值操作。基本上允许编译器使用memcpy()对类型进行赋值拷贝。还需要允许使用memcmp()对位进行比较。























