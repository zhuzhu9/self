## 标准库

#### 配置器

C++标准程序库在许多地方采用特殊对象来处理内存配置和寻址，这样的对象被称为配置器（allocator）。配置器体现出一种特定的内存模型，成为一个抽象表征，表现出“内存需求”至“内存低阶调用”的转换。

配置器最初是作为STL的一部分而引进的，用于处理如PC上不同指针型别这一类问题：现在作为一种技术方案的基础。

C++标准程序库定义了一个缺省配置器：

```cpp
namespace std{
    template <class T>
        class allocator;
}
```

### 通用工具

**通用型别（general types）**

#### Pairs（对组）

可以将两个值视为一个单元，C++标准程序库内多处使用了这个class。尤其map、multimap，就是使用pairs来管理其键值/实值（key/value）。

使用make_pair()可以生成一个pari对象。

#### Class auto_ptr

智能指针，帮助程序员防止“被异常抛出时发生资源泄漏”。一个对象只能有一个拥有者。

**auto_ptr拥有权的转移**

auto_ptr有严格拥有权观念，不能出现多个auto_ptr同时拥有一个对象。

## STL

全称standard template library，标准模板库或者泛型库，包含了大量模板类和模板函数。

**泛型：**不使用具体的数据类型，使用一种通用的类型来进行设计的方法，该方法可以大规模的减少程序代码的编写量，让程序员可以集中精力用于业务逻辑的实现。

通常认为，STL是由容器，算法，迭代器，函数对象，适配器，内存分配6部分组成的，其中，后面4部分是为前2部分服务的。

| STL组成  | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| 容器     | 一些封装数据结构的模板类，如vector、list。                   |
| 算法     | STL提供了很多的数据结构算法，都被设计成模板函数，算法在std命名空间中定义，大部分算法都在\<algorithm\>中，少部分在\<numeric\>中。 |
| 迭代器   | 在C++ STL中，对容器中的数据的读写，是通过迭代器完成的，扮演着容器和算法之间的粘合剂。 |
| 函数对象 | 如果一个类将()运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。 |
| 适配器   | 可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。 |
| 内存分配 | 为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。 |

**STL头文件**

| \<iterator> | \<functional> | \<vector>  | \<deque>  |
| ----------- | ------------- | ---------- | --------- |
| \<list>     | \<queue>      | \<stack>   | \<set>    |
| \<map>      | \<algorithm>  | \<numeric> | \<memory> |
| \<utility>  |               |            |           |

**STL 容器种类和功能**

| 容器种类 | 功能                                                         |
| -------- | ------------------------------------------------------------ |
| 排序容器 | 包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。 |
| 序列容器 | 主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。 |
| 哈希容器 | [C++](http://c.biancheng.net/cplus/) 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。 |

常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。

> 输入迭代器和输出迭代器比较特殊，它们不是把数组或容器当做操作对象，而是把输入流/输出流作为操作对象。

1. 前向迭代器（forward iterator）
   假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。

2. 双向迭代器（bidirectional iterator）
   双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 --p 或者 p-- 操作（即一次向后移动一个位置）。

3. 随机访问迭代器（random access iterator）
   随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：

- p+=i：使得 p 往后移动 i 个元素。

- p-=i：使得 p 往前移动 i 个元素。

- p+i：返回 p 后面第 i 个元素的迭代器。

- p-i：返回 p 前面第 i 个元素的迭代器。

- p[i]：返回 p 后面第 i 个元素的引用。

  此外，两个随机访问迭代器 p1、p2 还可以用 <、>、<=、>= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。



**不同容器的迭代器**（C++ 11 标准中不同容器指定使用的迭代器）

| 容器                               | 对应的迭代器类型 |
| ---------------------------------- | ---------------- |
| array                              | 随机访问迭代器   |
| deque                              | 随机访问迭代器   |
| forward_list                       | 前向迭代器       |
| list                               | 双向迭代器       |
| map / multimap                     | 双向迭代器       |
| queue                              | 不支持迭代器     |
| set / multiset                     | 双向迭代器       |
| stack                              | 不支持迭代器     |
| unordered_map / unordered_multimap | 前向迭代器       |
| unordered_set / unordered_multiset | 前向迭代器       |
| vector                             | 随机访问迭代器   |

**迭代器的 4 种定义方式**

| 迭代器定义方式 | 具体格式                                   |
| -------------- | ------------------------------------------ |
| 正向迭代器     | 容器类名::iterator 迭代器名;               |
| 常量正向迭代器 | 容器类名::const_iterator 迭代器名;         |
| 反向迭代器     | 容器类名::reverse_iterator 迭代器名;       |
| 常量反向迭代器 | 容器类名::const_reverse_iterator 迭代器名; |

#### 序列式容器

线性排列，用来存储某一指定类型的数据，不会自动排序。

- array\<T,N\>（数组容器）：可以存储N个T类型的元素，是C++本身提供的容器。长度固定，只能修改，不能增删。
- vector\<T\>（向量容器）：用来存放T类型的元素，是一个长度可变的容器，在空间不足时，会自动申请内存。尾部增删元素的效率最高（O(1)），其他位置增删效率O(n)。
- deque\<T\>（双端队列容器）：和vector相似，头尾部增删效率O(1)，其他位置增删效率O(n)。
- list\<T\>（链表容器）：长度可变，由T类型元素组成的序列，双向链表，在任何地方可以高效率增删（O(1)），访问元素慢。
- forward_list\<T\>（正向链表容器）：和list容器非常类似，单链表，比链表容器省内存。





![img](C++标准库和STL.assets\2-1P911110REB.jpg)

##### vector

​	源码使用了3个迭代器

```c++

template <class _Ty, class _Alloc = allocator<_Ty>>
class vector {
protected:
    pointer _Myfirst;
    pointer _Mylast;
    pointer _Myend;
};
```

\_Myfirst指向了vector容器对象的起始位置，\_Mylast指向了当前最后一个元素的末尾，\_Myend指向了容器占用内存的末尾。

![vector1](C++标准库和STL.assets\vector1.png)

通过3个可以灵活的表达容器中的信息，

- \_Myfirst 和 \_Mylast 可以用来表示 vector 容器中目前已被使用的内存空间。
- \_Mylast 和 \_Myend 可以用来表示 vector 容器目前空闲的内存空间。
- \_Myfirst 和 \_Myend 可以用表示 vector 容器的容量。
- 对于空的 vector 容器,由于没有任何元素的空间分配,因此 \_Myfirst、\_Mylast 和 \_Myend 均为NULL。



##### deque

- deque在头尾增删O(1)
- 也可以自身修改容量和大小

**deque不能保证所有元素都存储到连续的内存空间中。**当需要向序列两端频繁的添加或删除元素时，应该首选deque容器。

deque容器存储数据是由一段一段等长的连续空间构成的，

![image-20220114190722761](C++标准库和STL.assets\image-20220114190722761.png)

迭代器代码

```c++
template<class T, ...>
struct __deque_iteator{
    ...
    T* cur;
    T* first;
    T* last;
    map_pointer node; // map_pointer 等价于 T**
}
```

- cur：指向当前正在遍历的元素
- first：指向当前连续空间的首地址
- last：指向当前连续空间的末尾地址
- node：它是一个二级指针，用于指向map数组中存储的指向当前连续空间的指针

**deque容器**

```c++
//_Alloc为内存分配器
template<class _Ty, class _Alloc = allocator<_Ty>>
class deque{
protected:
	iterator start;
    iterator finish;
    map_pointer map;
}
```

2个deque迭代器和1个map数组，start迭代器记录map数组中首个连续空间的信息，finish迭代器记录map数组中最后一个连续空间的信息。

**注：**deque迭代器，和普通的deque迭代器不同，start迭代器中的cur指针指向的是连续空间中首个元素；finish迭代器，中的cur指针指向的是连续空间中最后一个元素的下一个位置。

![image-20220114194208845](C++标准库和STL.assets\image-20220114194208845.png)

##### list

双向链表容器，list容器中的元素可以分散在内存空间中，而不是必须存储在一整块连续的内存空间中。可以在已知的任何位置快速插入或删除元素O(1)。



























