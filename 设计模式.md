![img](assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYWppbmdsb25n,size_16,color_FFFFFF,t_70)

**常用的面向对象设计原则**

| 设计原则名称 | 定义                                             |
| ------------ | ------------------------------------------------ |
| 单一职责原则 | 一个类只负责一个功能领域中的相应职责             |
| 开闭原则     | 软件实体应对扩展开放，而对修改关闭               |
| 里氏代换原则 | 所有引用基类对象的地方能够透明地使用其子类 对象  |
| 依赖倒转原则 | 抽象不应该依赖细节，细节应该依赖于抽象           |
| 接口隔离原则 | 使用多个专门的接口，而不使用单一的总接口         |
| 合成复用原则 | 尽量使用对象组合，而不是继承来达到复用的目的     |
| 迪米特法则   | 一个软件实体应当尽可能少地与其他实体发生相互作用 |

**单一职责原则**：高内聚、低耦合。将类不同的职责分离。

**开闭原则**：软件实体应尽量在不修改原有代码的情况下进行扩展（软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类）。

**里氏代换原则**：在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常；反过来则不成立，如果一个软件实体使用的是一个子类对象，那么它不一定能够使用基类对象。

​	在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

- 子类方法必须在父类中声明，或子类必须实现父类中声明的所有方法。在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在父类定义的对象中使用该方法。
- 尽量把父类设计为抽象类或者接口，让子类继承父类或实现父类接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，

**依赖倒转原则**：尽量引用层次高的抽象层类，使用接口抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不是用具体类来做这些事情。

**迪米特法则**：不和“陌生人”说话，只与朋友通信。朋友包括：

- 对象本身（this）;
- 以参数形式传入到当前对象方法中的对象；
- 当前对象的成员对象；
- 如果当前对象的成员对象是一个集合，那么集合中的元素也是朋友；
- 当前对象所创建的对象。



#### 创造者模式

##### 简单工厂模式

​	定义一个工厂类，可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。简单工厂模式中用于创建实例的方法是static方法，因此简单工厂模式又称为静态工厂方法模式，属于类创建型模式。

​	当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

- Factory（工厂角色）：工厂类是简单工厂模式是核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象，工厂类中提供了静态的工厂方法factoryMethod(),返回类型为抽象产品类型Product。
- Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，所有创建的具体的产品对象都是其子类 。
- ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。

```c++
class Product{
public:
    Product();
    ~Product();
    virtual void methodDiff();//业务函数
}

class ConcreteProductA : public Product{
public:
    ConcreteProductA();
    ~ConcreteProductA();
    virtual void methodDiff(){}
}

class ConcreteProductB : public Product{
public:
    ConcreteProductB();
    ~ConcreteProductB();
    virtual void methodDiff(){}
}

class Factory{
public：
      	Product* getProduct(String arg){
        Product* product = nullptr;
        if(arg == "A"){
            product = new ConcreteProductA();
        }else if(arg == "B"){
            product = new ConcreteProductB();
        }
        return product
    }
}
```

```c++
#include <iostream>
#include "Factory.h"
#include "Product.h"

using namespace std;

int main(int argc,char* argv[]){
    Factory factory;
    Product* productA;
    Product* productB;
    productA = factory.getProduct("A");
    productB = factory.getProduct("B");
    productA.methodDiff();
    productB.methodDiff();
}
```



##### 单例模式

**定义**：一个类只允许创建一个对象。

**用处**：业务逻辑中，有些数据只应该保存一份。

















































