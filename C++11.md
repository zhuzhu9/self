modern c++

- 统一的类成员初始化语法与 std::initializer_list
- 注解标签（attributes）
- final/override/=default/=delete 语法
- auto 关键字
- Range-based 循环语法
- 结构化绑定
- stl 容器新增的实用方法
- std::thread
- 线程局部存储 thread_local
- 线程同步原语 std::mutex、std::condition_variable 等
- 原子操作类
- 智能指针类
- std::bind/std::function



c++11

- 废弃了不实用的语法和库(如std::auto_ptr)，改进了、或增强了c++98/03中一些语法元素（auto），新增了其他语言早已经支持的关键字和语法（如final、=default语法、=delete语法）。
- 增加了对操作系统功能的支持（如线程库、时间库）。



c++14：变动较小，主要对c++11新特性做了一些完善，或小修正

- 对c++11新增的std::shared_ptr、std::unique_ptr，C++11新增了std::make_shared()函数创建一个std::shared_ptr，没有std::make_unique()，c++14被引入
-  std::unique_lock 在 C++11 引入，std::shared_lock 在 C++14 才引入。



c++17

- 结构化绑定
- 优化了一些特性，例如对 Range-based 语法的增强



c++20：进一步弥补“功能不完备性”，

- C++程序中的一些功能（如文件操作、协程等）需要直接调用操作系统的 API ，而不像其他语言自带 SDK，



- 《深入理解 C++11：C++11 新特性解析与应用》
- 《深入应用 C++11：代码优化与工程级应用》
- 《C++17 完全指南》
- 《Cpp 17 in Detail》

##### 智能指针

###### shared_ptr

​	遵守共享所有权的概念，不同的shared_ptr对象可以与相同的指针关联，并且在内部引用计数机制来实现。

​	**shared_ptr对象内部指向两块内存区域**

- 指向对象
- 指向用于引用计数的控制数据

​	**共享所有权怎样在引用计数的帮助下工作**

- 当一个新的shared_ptr对象与一个指针相关联时，在它的构造函数中，它将与这个指针相关的引用计数增加1。
- 当任何shared_ptr对象超出作用域时，则在其析构函数中将相关指针的引用计数递减1.当引用计数变为0时，意味着没有任何shared_ptr对象与这块内存关联，在这种情况下，它使用“删除”功能删除这块内存。

创建shared_ptr对象：当我们将shared_ptr对象与原始指针绑定时：

```c++
std::shared_ptr<int> p1(new int());
```

在堆上分配两块内存：

- 为int分配内存
- 用于引用计数的内存，将用于管理与此内存相关的shared_ptr对象，初始值为1。

**检查shared_ptr对象的引用计数**

```c++
p1.use_count();
```



###### std::make_shared\<T\>

**如何分配指向shared_ptr的指针**

```c++
//std::shared_ptr<int> p1 = new int();// Error
std::shared_ptr<int> p1 = std::make_shared<int>();
```

​	std::make_shared为引用计数所需的对象和数据结构做了一次内存分配，新运算符只会被调用一次。

**分离关联的原始指针**

​	可以调用reset()使std::shared_ptr对象解除连接它的指针

- 无参数的reset()函数

  ```c++
  p1.reset();
  ```

  它将引用计数减1,如果引用计数变为0,则删除指针

- 有参数的reset()函数

  ```c++
  p1.reset(new int(34));
  ```

  在这种情况下，它将在内部指向，因此其引用计数将再次变为1。

- 使用nullptr重置

  ```c++
  p1 = nullptr;

**shared_ptr是一个伪指针**
	shared_ptr作为普通的指针，即我们可以在shared_ptr对象上使用*和->，也可以像其他shared_ptr对象那样进行比较。

###### weak_ptr

​	weak_ptr允许共享，但不拥有一个对象，它的对象是由shared_ptr创建的。

​	weak_ptr不能直接使用*和->访问。需要通过weak_ptr的lock()函数创建shared_ptr，才能访问。

```c++
#include <iostream>
#include <memory>
 
int main() {
  std::shared_ptr<int> ptr = std::make_shared<int>(4);
  std::weak_ptr<int> weakPtr(ptr);
  std::shared_ptr<int> ptr_2 = weakPtr.lock();
  if (ptr_2)
    std::cout << (*ptr_2) << std::endl;
  std::cout << "Reference Count :: " << ptr_2.use_count() << std::endl;
  if (weakPtr.expired() == false)
    std::cout << "Not expired yet" << std::endl;
 
  return 0;
}
```

与weak_ptr绑定的shared_ptr被删除，lock()会返回一个空的shared_ptr。

###### std::unique_ptr

​	unique_ptr对象包含一个原始指针，并负责其生命周期。当对象被销毁时，会删除原始指针。可以使用*和->访问数据。

**唯一指针的唯一所有权**

​	unique_ptr对象始终是关联原始指针的唯一所有者。不能复制unique_ptr对象，只能移动。

**转移unique_ptr对象所有权**

```c++
{
    std::unique_ptr<int> p(new int(5));
    std::unique_ptr<int> p2 = std::move(p);
}
```

​	std::move()转移所有权，转移后p为空。

##### std::function

​	std::function是函数模板类，std::bind是函数模板。

```c++
#include <iostream>
#include <string>
#include <functional>

using namespace std;

std::function<void(int a)> fun1;
std::function<void(string str)> fun2;
std::function<string(int a, int b)> fun3;

void func1(int a){}

static void staticFunc(string str){}

auto lambda = [](int a, int b)->string{return "a";}

int main(){
    fun1 = func1;
    fun1(3);
    fun2 = staticFunc;
    fun2("b");
    fun3 = lambda;
    fun3(1,2);
}
```





《**Effective Modern C++**》

















