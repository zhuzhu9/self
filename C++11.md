modern c++

- 统一的类成员初始化语法与 std::initializer_list
- 注解标签（attributes）
- final/override/=default/=delete 语法
- auto 关键字
- Range-based 循环语法
- 结构化绑定
- stl 容器新增的实用方法
- std::thread
- 线程局部存储 thread_local
- 线程同步原语 std::mutex、std::condition_variable 等
- 原子操作类
- 智能指针类
- std::bind/std::function



c++11

- 废弃了不实用的语法和库(如std::auto_ptr)，改进了、或增强了c++98/03中一些语法元素（auto），新增了其他语言早已经支持的关键字和语法（如final、=default语法、=delete语法）。
- 增加了对操作系统功能的支持（如线程库、时间库）。



c++14：变动较小，主要对c++11新特性做了一些完善，或小修正

- 对c++11新增的std::shared_ptr、std::unique_ptr，C++11新增了std::make_shared()函数创建一个std::shared_ptr，没有std::make_unique()，c++14被引入
-  std::unique_lock 在 C++11 引入，std::shared_lock 在 C++14 才引入。



c++17

- 结构化绑定
- 优化了一些特性，例如对 Range-based 语法的增强



c++20：进一步弥补“功能不完备性”，

- C++程序中的一些功能（如文件操作、协程等）需要直接调用操作系统的 API ，而不像其他语言自带 SDK，



- 《深入理解 C++11：C++11 新特性解析与应用》
- 《深入应用 C++11：代码优化与工程级应用》
- 《C++17 完全指南》
- 《Cpp 17 in Detail》

##### 智能指针

###### shared_ptr

​	遵守共享所有权的概念，不同的shared_ptr对象可以与相同的指针关联，并且在内部引用计数机制来实现。

​	**shared_ptr对象内部指向两块内存区域**

- 指向对象
- 指向用于引用计数的控制数据

​	**共享所有权怎样在引用计数的帮助下工作**

- 当一个新的shared_ptr对象与一个指针相关联时，在它的构造函数中，它将与这个指针相关的引用计数增加1。
- 当任何shared_ptr对象超出作用域时，则在其析构函数中将相关指针的引用计数递减1.当引用计数变为0时，意味着没有任何shared_ptr对象与这块内存关联，在这种情况下，它使用“删除”功能删除这块内存。

创建shared_ptr对象：当我们将shared_ptr对象与原始指针绑定时：

```c++
std::shared_ptr<int> p1(new int());
```

在堆上分配两块内存：

- 为int分配内存
- 用于引用计数的内存，将用于管理与此内存相关的shared_ptr对象，初始值为1。

**检查shared_ptr对象的引用计数**

```c++
p1.use_count();
```



###### std::make_shared\<T\>

**如何分配指向shared_ptr的指针**

```c++
//std::shared_ptr<int> p1 = new int();// Error
std::shared_ptr<int> p1 = std::make_shared<int>();
```

​	std::make_shared为引用计数所需的对象和数据结构做了一次内存分配，新运算符只会被调用一次。

**分离关联的原始指针**

​	可以调用reset()使std::shared_ptr对象解除连接它的指针

- 无参数的reset()函数

  ```c++
  p1.reset();
  ```

  它将引用计数减1,如果引用计数变为0,则删除指针

- 有参数的reset()函数

  ```c++
  p1.reset(new int(34));
  ```

  在这种情况下，它将在内部指向，因此其引用计数将再次变为1。

- 使用nullptr重置

  ```c++
  p1 = nullptr;

**shared_ptr是一个伪指针**
	shared_ptr作为普通的指针，即我们可以在shared_ptr对象上使用*和->，也可以像其他shared_ptr对象那样进行比较。







《**Effective Modern C++**》

















